name: report-rari-build-issues

on:
  workflow_call:
    inputs:
      rari-issues-artifact-id:
        description: The ID of the artifact containing the issues.json file
        required: true
        type: string
      content-path:
        description: The path to the content directory to strip from file paths
        required: true
        type: string

permissions:
  checks: write
  pull-requests: read

jobs:
  report-build-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        id: download-artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: ${{ inputs.rari-issues-artifact-id }}
          path: ./rari-issues

      - name: Report build issues
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          CONTENT_PATH: ${{ inputs.content-path }}
          ISSUES_PATH: ${{ steps.download-artifact.outputs.download-path }}/issues.json
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            const issuesByPath = JSON.parse(fs.readFileSync(process.env.ISSUES_PATH, "utf8"));

            const filepaths = Object.keys(issuesByPath);
            const annotations = [];

            for (const [filepath, issues] of Object.entries(issuesByPath)) {
              const prefix = process.env.CONTENT_PATH;

              if (!filepath.includes(prefix)) {
                continue;
              }

              const file = filepath.replace(prefix, "");

              for (const issue of issues) {
                const {
                  line: startLine,
                  col: startColumn,
                  end_line: endLine,
                  end_col: endColumn,
                } = issue;

                const {
                  source = "unknown",
                  ...otherFields
                } = Object.fromEntries(issue.fields);

                const payload = Object.entries(otherFields)
                  .map(([key, value]) => `${key}: ${value}`)
                  .join(" â€¢ ");

                const message = source ? `(${source}) ${payload}` : payload;

                annotations.push({
                  path: file,
                  start_line: startLine,
                  end_line: endLine,
                  start_column: startColumn,
                  end_column: endColumn,
                  annotation_level: "warning",
                  message: message,
                });
              }
            }

            // Create check run with annotations if this is a pull request
            if (context.payload.pull_request) {
              const { owner, repo } = context.repo;
              const sha = context.payload.pull_request.head.sha;

              await github.rest.checks.create({
                owner,
                repo,
                name: "Build Issues",
                head_sha: sha,
                status: "completed",
                conclusion: annotations.length > 0 ? "neutral" : "success",
                output: {
                  title: annotations.length > 0 ? `Found ${annotations.length} issue(s) in ${filepaths.length} file(s)` : "No issues found.",
                  summary: annotations.length > 0
                    ? `Found ${annotations.length} issue(s) in ${filepaths.length} file(s).`
                    : "No issues found.",
                  annotations: annotations.slice(0, 50),
                },
              });

              core.info(`Created check run`);
            } else {
              // Fallback to warnings for non-PR contexts
              for (const annotation of annotations) {
                core.warning(annotation.message, {
                  file: annotation.path,
                  startLine: annotation.start_line,
                  endLine: annotation.end_line,
                  startColumn: annotation.start_column,
                  endColumn: annotation.end_column,
                });
              }
            }
